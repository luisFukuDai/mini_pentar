/***********************************************************************/
/*                                                                     */
/*  FILE        :control.c                                             */
/*  DATE        :Thu, May 29, 2014                                     */
/*  DESCRIPTION :Control programs of the robot                         */
/*  CPU TYPE    :RX621                                                 */
/*                                                                     */
/*  This file is generated by Shuta KAMIO.                             */
/*                                                                     */
/***********************************************************************/

#include "iodefine.h"
#include "stdio.h"
#include "math.h"
#include "stdlib.h"
#include "interrupt_handlers.h"
#include "global.h"
#include "sci.h"
#include "adc.h"
#include "timer.h"
#include "pwm.h"
#include "encoder.h"
#include "queue.h"
#include "control.h"

MOTOR wheelMotor[4];
float x;
float phi;

float dX;
float dPhi;

unsigned long MTU_TGRB_1_7[2] = {0x0008870A,0x00088B0A};


ESO eso[4];

float adaptFilterMotor1(float x)
{

  static float xHat;
  static float dXHat;
  static float w0 = 20.0;
  static int first;

  static float dqHat;

  float alpha;
  float e;

  if(first == 1) {
    first = 1;
    xHat = x;
  }

  e = x-xHat;

  xHat  = xHat + dt*(dXHat + 2*w0*e); 
  dXHat = dXHat + dt*( w0*w0*e); 


  alpha = fabs(dXHat*0.5) + 0.01;

  if(alpha >= 0.9)
    alpha = 0.9;

  dqHat = (1-alpha)*dqHat + alpha*x;


  return dXHat;
}

float adaptFilterMotor2(float x)
{

  static float xHat;
  static float dXHat;
  static float w0 = 20.0;
  static int first;

  static float dqHat;

  float alpha;
  float e;

  if(first == 1) {
    first = 1;
    xHat = x;
  }

  e = x-xHat;

  xHat  = xHat + dt*(dXHat + 2*w0*e); 
  dXHat = dXHat + dt*( w0*w0*e); 


  alpha = fabs(dXHat*0.5) + 0.01;

  if(alpha >= 0.9)
    alpha = 0.9;

  dqHat = (1-alpha)*dqHat + alpha*x;


  return dXHat;
}


float doubleMotorTorque0(float tau)
{
  float voltage;
  float voltageA,voltageB;
  float alpha = 2.0;//volts
  float velocity;

  tau /= (14.0*28.0/20.0);
  tau /= 2.0;//double motor

  velocity = adaptFilterMotor1(wheelMotor[0].q);
  voltage = 5.53*(tau/10.9e-3) + 10.9e-3*velocity*(14.0*28.0/20.0)/2;

  voltageA = voltage + alpha;
  voltageB = voltage - alpha ;


  if(voltageA > 12.0)
    voltageA = 12.0;
  else if(voltageA < -12.0)
    voltageA = -12.0;


  if(voltageB > 12.0)
    voltageB = 12.0;
  else if(voltageB < -12.0)
    voltageB = -12.0;


  wheelMotor[0].pwmVal = voltageA/14.0;
  wheelMotor[2].pwmVal = voltageB/14.0;


  if( voltage > 12.0 )
    voltage = 12.0;
  else if( voltage < -12.0 )
    voltage = -12.0;

  return ((voltage - 10.9e-3*velocity*(14.0*28.0/20.0)/2)*10.9e-3/5.53*2.0)/20.0*28.0*14.0;

}

float doubleMotorTorque1(float tau)
{
  float voltage;
  float voltageA,voltageB;
  float alpha = 2.0;//volts
  float velocity;

  tau /= (14.0*28.0/20.0);
  tau /= 2.0;//double motor

  velocity = adaptFilterMotor1(wheelMotor[1].q);
  voltage = 5.53*(tau/10.9e-3) + 10.9e-3*velocity*(14.0*28.0/20.0)/2;

  voltageA = voltage + alpha;
  voltageB = voltage - alpha ;


  if(voltageA > 12.0)
    voltageA = 12.0;
  else if(voltageA < -12.0)
    voltageA = -12.0;


  if(voltageB > 12.0)
    voltageB = 12.0;
  else if(voltageB < -12.0)
    voltageB = -12.0;


  wheelMotor[1].pwmVal = voltageA/14.0;
  wheelMotor[3].pwmVal = voltageB/14.0;

  if( voltage > 12.0 )
    voltage = 12.0;
  else if( voltage < -12.0 )
    voltage = -12.0;

  return ((voltage - 10.9e-3*velocity*(14.0*28.0/20.0)/2)*10.9e-3/5.53*2.0)/20.0*28.0*14.0;

}


void esoCalc(short n)
{
  ESO *gs;
  float e;

  if(eso[n].first == 0){
    eso[n].first = 1;
    eso[n].xHat[0] = eso[n].x;
    eso[n].xHat[1] = 0;
    eso[n].xHat[2] = 0;
  }

  gs = &(eso[n]);

  gs->x = wheelMotor[n].q;
  gs->u = wheelMotor[n].u;

  e = gs->x - gs->xHat[0];
  
  gs->xHat[0] =  gs->xHat[0] + dt*(gs->xHat[1] + gs->l[0]*e);
  gs->xHat[1] =  gs->xHat[1] + dt*(gs->xHat[2] + gs->l[1]*e + (gs->b)*(gs->u));
  gs->xHat[2] =  gs->xHat[2] + dt*((gs->l[2])*e);

}


void getMotorState(short n)
{
  int timeNow;
  int cetDelta;
  int qNow;
  int qDelta;

  qNow = getEncCnt(wheelMotor[n].encOffset);
  qDelta = qNow - wheelMotor[n].qOld;

  wheelMotor[n].qTotalCount += qDelta;

  wheelMotor[n].q = wheelMotor[n].encPolarity*wheelMotor[n].qTotalCount*2.0*M_PI/(400.0*14.0*28.0/20.0);

  timeNow = getEncCap(n);
  cetDelta = timeNow - wheelMotor[n].timeOld;

  if(cetDelta == 0){
    wheelMotor[n].dQ = 0;
  }else{
    wheelMotor[n].dQ = wheelMotor[n].encPolarity*(2.0 * M_PI * (qDelta)) / (400.0*14.0*28.0/20.0 * (cetDelta)/(48000000.0/64.0));
  }

  wheelMotor[n].qOld = qNow;
  wheelMotor[n].timeOld = timeNow;

  esoCalc(n);

}

void setMotorPwmValue(short n, float pwmVal)
{
  setDutyDoubleDC(n, wheelMotor[n].pwmPolarity*pwmVal);
}

void initMotorParam(void)
{
  float w0 = 18.0;

  wheelMotor[0].pwmOffset = 0;
  wheelMotor[0].encOffset = 0;
  wheelMotor[0].pwmPolarity = -1;
  wheelMotor[0].encPolarity = -1;
  eso[0].b = 25.0;
  eso[0].l[0] = w0*3.0;
  eso[0].l[1] = w0*w0*3.0;
  eso[0].l[2] = w0*w0*w0;


  wheelMotor[1].pwmOffset = 1;
  wheelMotor[1].encOffset = 1;
  wheelMotor[1].pwmPolarity = -1;
  wheelMotor[1].encPolarity = 1;
  eso[1].b = 25.0;
  eso[1].l[0] = w0*3.0;
  eso[1].l[1] = w0*w0*3.0;
  eso[1].l[2] = w0*w0*w0;

  wheelMotor[2].pwmOffset = 2;
  wheelMotor[2].encOffset = 0;
  wheelMotor[2].pwmPolarity = -1;
  wheelMotor[2].encPolarity = -1;
  eso[2].b = 25.0;
  eso[2].l[0] = w0*3.0;
  eso[2].l[1] = w0*w0*3.0;
  eso[2].l[2] = w0*w0*w0;

  wheelMotor[3].pwmOffset = 3;
  wheelMotor[3].encOffset = 1;
  wheelMotor[3].pwmPolarity = 1;
  wheelMotor[3].encPolarity = 1;
  eso[3].b = 25.0;
  eso[3].l[0] = w0*3.0;
  eso[3].l[1] = w0*w0*3.0;
  eso[3].l[2] = w0*w0*w0;

}


void wheelControl()
{

  static float t;
  float e;

  t+=0.001;


  e = -( (eso[0].xHat[1]+wheelMotor[0].dQ)*0.5 - wheelMotor[0].dQD);

  doubleMotorTorque0(0.5*e);
  

  e = -( (eso[1].xHat[1]+wheelMotor[1].dQ)*0.5 - wheelMotor[1].dQD);

  doubleMotorTorque1(0.5*e);


}



